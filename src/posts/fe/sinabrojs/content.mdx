---
title: '시나브로 자바스크립트 1주차 스터디 정리'
desc: '시나브로 자바스크립트 1주차 스터디 정리를 한 내용을 작성했습니다.'
date: 2025-02-14
thumbnail: /posts/fe/sinabrojs/image.png
---

<Callout type="info">
먼저, 웹 서버가 정적 파일을 제공하는 방식과 번들러의 역할에 대해 알아보겠습니다.
</Callout>

# 웹 서버와 정적 파일 제공

웹 서버는 인터넷을 통해 사용자의 브라우저에 웹 페이지를 전달하는 역할을 합니다. 기본적으로 웹 서버는 HTML, CSS, JavaScript 등의 정적 파일을 저장하고 있으며, 사용자가 웹사이트를 방문할 때 이 파일들을 제공합니다.

## 주요 정적 파일의 종류와 역할

### [1] HTML
- HyperText Markup Language의 약자
- 웹 페이지의 기본 구조를 정의
- 사용자가 웹사이트 주소를 입력하면 웹 서버는 `index.html`과 같은 기본 HTML 파일을 먼저 전송

### [2] CSS
- Cascading Style Sheets의 약자
- 웹 페이지의 시각적 스타일을 정의
- 색상, 글꼴, 간격 등 디자인 요소를 조정
- HTML 파일 로딩 후 추가로 요청되어 적용

### [3] JavaScript
- 웹 페이지에 동적 요소를 추가하는 스크립팅 언어
- 사용자 상호작용, 데이터 처리, DOM 조작 등을 담당
- 웹 페이지가 브라우저에 로드된 후 실행

# 번들러의 이해

## 번들러란?
번들러는 웹 개발 과정에서 여러 개의 파일과 모듈을 하나의 파일로 결합하여 관리하는 도구입니다. 개발의 효율성과 성능을 극대화하며, 개발 과정을 체계적으로 관리할 수 있도록 도와줍니다.

## 번들러의 주요 역할

### [1] 성능 최적화
- 여러 파일을 하나로 병합
- 서버 요청 수 감소
- 페이지 로딩 시간 단축

### [2] 전처리 지원
- CSS 전처리기: Sass, LESS
- JavaScript 전처리기: TypeScript, Babel
- 개발 과정 간소화

### [3] 모듈 호환성
- 다양한 모듈 형식 지원
- npm 패키지와의 원활한 통합
- 의존성 관리 자동화

### [4] 개발 편의성
- 자동 리로드 기능
- 핫 리플레이스먼트
- 실시간 변경사항 반영

## 대표적인 번들러

1. **Webpack**
   - 가장 널리 사용되는 번들러
   - 강력한 커스터마이징 지원
   
2. **Parcel**
   - 'Zero Configuration' 지향
   - 간편한 설정
   
3. **Rollup**
   - ES 모듈 중심 설계
   - 현대적 자바스크립트 개발에 최적화
   
4. **Vite**
   - 빠른 빌드 속도
   - 간단한 설정
   - 최신 프론트엔드 개발 트렌드 반영

# 실제 적용 사례

## 번들러의 실제 사용
React 프로젝트에서는 JSX 파일과 CSS 파일을 하나의 JavaScript 파일로 번들링하는 과정이 필요합니다. 번들러는 이러한 복잡한 의존성 관리와 성능 최적화를 자동으로 처리해주어, 개발자가 애플리케이션 로직 개발에 집중할 수 있게 해줍니다.

## Netlify를 통한 배포
- HTML 파일 생성 및 Netlify 배포
- 자동화된 서버 설정 관리
- 로컬 개발 환경(`localhost`)에서 테스트 후 실제 배포

이처럼 번들러를 활용하면 웹 개발의 효율성과 성능을 최대화하고, 개발 과정을 체계적으로 관리할 수 있습니다. 결과적으로 사용자에게 더 빠르고 효율적인 웹 애플리케이션을 제공할 수 있게 됩니다.



<Callout type="info">
이제 Tailwind CSS의 이해와 활용에 대해 알아보겠습니다.
</Callout>

# [chapter 2] Tailwind CSS의 이해와 활용

## Tailwind CSS란?
Tailwind CSS는 유틸리티 우선(Utility-First) 접근 방식을 채택한 CSS 프레임워크입니다. 재사용 가능하고 조합하기 쉬운 유틸리티 클래스를 제공하여, 빠르고 유연한 디자인 구현이 가능합니다.

## 주요 특징

### [1] 유틸리티 클래스 시스템
- 미리 정의된 클래스로 스타일 적용
- 각 클래스는 특정 스타일 속성 담당 (예: `w-0`는 width: 0px)
- 레고 블록처럼 조합하여 디자인 구성

### [2] 반응형 디자인
- 미디어 쿼리 기반 클래스 제공
- 다양한 화면 크기에 대응
- 직관적인 반응형 구현

## CDN과 Tailwind CSS

### CDN 사용의 한계점
1. **큰 파일 크기**
   - 전체 라이브러리 로드 필요
   - 불필요한 스타일 포함
   - 웹사이트 로딩 시간 증가

2. **제한된 커스터마이징**
   - 기본 설정만 사용 가능
   - 프로젝트별 최적화 어려움

### 번들러를 통한 최적화

#### [1] JIT(Just-in-Time) 컴파일
- 실시간으로 필요한 CSS만 생성
- 개발 과정 최적화
- 최종 CSS 크기 감소

#### [2] 번들러 통합의 이점
- 리소스 크기 최소화
- 로딩 시간 단축
- 성능 향상

## Tailwind CSS의 장점

1. **개발 효율성**
   - 빠른 스타일 적용
   - 직관적인 클래스명
   - 일관된 디자인 시스템

2. **유지보수성**
   - HTML 내 스타일 관리
   - 클래스 재사용 용이
   - 스타일 충돌 최소화

3. **성능 최적화**
   - 사용된 스타일만 포함
   - 번들 크기 최적화
   - 빠른 로딩 시간

이처럼 Tailwind CSS는 현대 웹 개발에서 효율적인 스타일링 솔루션을 제공하며, 번들러와의 통합을 통해 최적화된 개발 경험을 제공합니다.


------

# [chapter 3] DomAPI - 1 addEventListener

<Callout type="info">
addEventListener, 이제 이벤트 리스너를 추가하는 방법에 대해 알아보겠습니다. 
</Callout>

웹 개발에서 사용자의 상호작용을 관리하는 핵심 기능 중 하나는 이벤트 리스너를 추가하는 것입니다. JavaScript의 `addEventListener` 메소드는 이를 위한 강력한 도구입니다. 이 글에서는 `addEventListener`의 사용법과 이벤트 처리 패턴에 대해 자세히 살펴보겠습니다.

#### 이벤트 리스너 추가하기

`addEventListener`는 특정 이벤트가 발생했을 때 호출될 함수를 요소에 연결합니다. 기본적인 사용법은 다음과 같습니다:

`element.addEventListener('event', function);

여기서 `element`는 DOM에서의 요소, `event`는 반응할 이벤트의 종류, 그리고 `function`은 이벤트 발생 시 실행할 함수를 의미합니다.

#### 이벤트 처리 함수

이벤트 리스너에 할당된 함수는 이벤트 객체를 인자로 받아 다양한 데이터에 접근할 수 있습니다. 예를 들어, `event.target` 속성을 사용하여 이벤트가 발생한 요소의 정보를 얻을 수 있습니다.

#### 이벤트 버블링과 캡처링

DOM 이벤트는 두 가지 방식으로 전파됩니다: 버블링과 캡처링.

- **버블링**: 이벤트가 발생한 요소에서 시작해 DOM 트리를 거슬러 올라가면서 각 요소에서 이벤트 리스너를 실행합니다.
- **캡처링**: 이벤트가 DOM 트리의 최상위에서 시작하여 발생 요소로 내려가면서 리스너를 실행합니다.

이벤트 전파를 중지하고 싶을 때는 `event.stopPropagation()` 메소드를 사용합니다. 이 메소드는 이벤트가 더 이상 전파되지 않도록 중단합니다.

#### 다양한 이벤트 유형

다양한 요소에 맞는 적절한 이벤트 유형을 선택하는 것이 중요합니다. 예를 들어 입력 필드에서는 `input` 이벤트를 사용하여 사용자 입력을 실시간으로 감지할 수 있고, `change` 이벤트는 입력 필드에서 포커스가 벗어났을 때 변경사항을 감지할 때 유용합니다.

#### 키보드 이벤트 처리

키보드 이벤트를 사용하면 키보드 입력에 반응하는 기능을 구현할 수 있습니다. `keyup` 이벤트를 사용하여 특정 키 조합을 감지하고, 사용자에게 보다 효율적인 인터랙션을 제공할 수 있습니다.

```js
document.addEventListener('keyup', function(event) {     
	if (event.key === 'Enter') {         
	console.log('Enter 키가 눌렸습니다!');     
} });
```

`addEventListener`는 웹 페이지에서 사용자의 상호작용을 효과적으로 관리하고, 다양한 이벤트에 반응하는 동적인 웹 애플리케이션을 구현할 수 있는 필수적인 도구임을 알 수 있습니다.


# [chapter 4] DomAPI - 2 innerHTML의 비효율성과 그 대안들

<Callout type="info">
innerHTML, 이제 이벤트 리스너를 추가하는 방법에 대해 알아보겠습니다.
</Callout>

웹 개발에서 DOM을 조작하는 것은 매우 흔한 작업입니다. 그 중에서도 `innerHTML` 속성을 사용하여 요소의 HTML을 쉽게 변경할 수 있지만, 이 방법은 특정 상황에서 비효율적일 수 있습니다. 이 글에서는 `innerHTML`의 작동 방식과 그 한계, 그리고 효율적인 대안에 대해 알아보겠습니다.

#### `innerHTML`의 작동 원리

`innerHTML` 속성은 문자열을 통해 HTML 요소의 내용을 바꾸는 가장 간단한 방법 중 하나입니다. 예를 들어, 다음과 같은 코드가 있다고 가정해 보겠습니다:

`document.querySelector('#app').innerHTML = '<p>Updated content</p>';

이 코드는 ID가 'app'인 요소의 내부 HTML을 새로운 내용으로 교체합니다. 간단하고 직관적이죠.

#### `innerHTML` 사용 시의 문제점

하지만 `innerHTML`을 사용할 때 몇 가지 문제가 발생할 수 있습니다:

1. **성능 저하**: `innerHTML`을 사용하면 지정된 요소의 자식 요소 전체를 파싱하고 새로운 노드로 교체해야 하므로, 대규모 DOM에서는 성능에 부정적인 영향을 줄 수 있습니다.
    
2. **스크립트 재실행**: `innerHTML`로 삽입된 HTML 안에 `<script>` 태그가 있으면, 이 스크립트는 실행되지 않습니다.
    
3. **상태 손실**: 기존 요소를 새 요소로 완전히 교체하면, 이전 요소의 모든 상태(예: 입력 필드의 값, 포커스 상태)가 손실됩니다. 예를 들어, 사용자가 입력 필드에 데이터를 입력하는 동안 `innerHTML`이 실행되면 입력 중이던 데이터와 포커스가 모두 사라집니다.
    

#### 효율적인 대안

이러한 문제를 해결하기 위해 다른 DOM 조작 방법을 사용할 수 있습니다:

4. **`textContent`와 `innerText`**: 단순 텍스트 내용만 변경해야 할 경우, `textContent` 또는 `innerText` 속성을 사용하면 불필요한 HTML 파싱 과정을 거치지 않아도 됩니다.
    
5. **`createElement`와 `appendChild`**: 새 요소를 추가할 때는 `createElement`로 요소를 만든 후 `appendChild`를 사용하여 DOM에 추가하는 방법이 효율적입니다. 이 방법은 기존의 DOM 구조를 유지하면서 새 요소만 추가하므로, 전체를 다시 로드할 필요가 없습니다.
    
6. **프레임워크 사용**: React나 Vue 같은 현대적인 프론트엔드 프레임워크는 DOM을 효율적으로 조작하는 자체 메커니즘을 제공합니다. 예를 들어, React는 가상 DOM을 사용하여 변경이 필요한 부분만 실제 DOM에 반영합니다. 이는 성능을 크게 향상시키고 상태 손실 문제를 방지합니다.
    

#### 결론

`innerHTML`은 특정 상황에서 유용할 수 있지만, 큰 규모의 어플리케이션 또는 동적인 요소가 많은 인터랙티브 웹 페이지에서는 그 한계가 명확합니다. 효율적인 DOM 조작을 위해서는 `innerHTML`의 대안을 적극적으로 고려하고, 가능한 경우 현대적인 프론트엔드 프레임워크를 활용하는 것이 좋습니다. 이러한 방법들은 성능을 향상시키고, 사용자 경험을 개선하는데 크게 기여할 것입니다.


# [chapter 5] DomAPI - 3 대량의 이벤트 처리

<Callout type="info">
이제 대량의 이벤트 처리에 대해 알아보겠습니다.
</Callout>

웹 개발에서 대량의 DOM 요소에 이벤트 리스너를 효율적으로 관리하는 방법은 성능 최적화와 직결됩니다. 이번 튜토리얼에서는 여러 카드 요소에 이벤트 리스너를 추가하고, 이벤트 처리를 위한 다양한 접근법을 탐구해 보겠습니다.

#### 동적 요소에 이벤트 리스너 추가하기

예를 들어, 사용자가 '카드 추가' 버튼을 클릭할 때마다 새로운 카드가 화면에 추가되고, 각 카드에 특정 기능을 수행하는 버튼이 포함된다고 가정해 봅시다. 이 경우, 각각의 새로운 버튼에 개별적으로 이벤트 리스너를 추가하는 것은 비효율적일 수 있습니다. 대신, 다음과 같은 접근법을 고려할 수 있습니다:

1. **이벤트 위임 사용**: 하나의 공통된 상위 요소에 이벤트 리스너를 추가하고, 이벤트가 발생했을 때 이벤트 타겟의 종류를 체크하여 적절한 동작을 수행하게 합니다. 이 방식은 메모리 사용을 줄이고, 동적으로 요소가 추가되거나 제거될 때 이벤트 리스너를 재할당할 필요가 없어 성능을 개선할 수 있습니다.

```js
document.querySelector('.card-container').addEventListener('click', function(event) {
    if (event.target.matches('.button-class')) {
        // 버튼 클릭 시 실행할 코드
    }
});
````

#### 클로저를 활용한 이벤트 데이터 관리

각 이벤트 리스너 내에서 특정 데이터(예: 카드 인덱스)에 접근해야 할 경우, 클로저를 사용하여 해당 데이터를 이벤트 리스너와 연결할 수 있습니다. 이 방법은 각 버튼에 대한 정보를 보존하면서도, 그 정보가 외부에서 쉽게 변경될 수 없도록 캡슐화합니다.

```js
function createCard(index) {
    const button = document.createElement('button');
    button.textContent = '카드 ' + index;
    button.addEventListener('click', function() {
        alert('카드 ' + index + '가 클릭됐습니다');
    });
    document.body.appendChild(button);
}

```
#### 데이터 속성 활용

HTML5의 데이터 속성(`data-*`)을 활용하여 요소에 추가 정보를 저장할 수 있습니다. 이 정보는 이벤트가 발생했을 때 쉽게 접근할 수 있으며, 동적으로 생성된 요소의 상태나 속성을 유지하는 데 유용합니다.

```js
button.dataset.index = index;
document.querySelector('.card-container').addEventListener('click', function(event) {
    if (event.target.dataset.index) {
        console.log('카드 ' + event.target.dataset.index + ' 클릭됨');
    }
});

```
#### 결론

대량의 요소에 이벤트 리스너를 효율적으로 관리하는 방법은 웹 애플리케이션의 성능에 큰 영향을 미칩니다. 이벤트 위임, 클로저, 데이터 속성을 적절히 활용하여 리소스를 절약하고, 유지보수가 용이하며, 확장 가능한 코드를 작성해야 합니다. 이러한 기술들은 현대 웹 개발에서 필수적인 요소이며, 이를 통해 사용자 경험을 향상시키고 개발 효율성을 높일 수 있습니다.